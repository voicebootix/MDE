import React, { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Wrench,
  Code,
  Puzzle,
  Settings,
  Download,
  Zap,
  BrainCircuit,
  Rocket,
  AlertTriangle,
  CheckCircle,
  Shield,
  Users
} from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { InvokeLLM } from "@/api/integrations";

import TechStackRecommendations from "../components/cto/TechStackRecommendations";
import FullFrontendGenerator from "../components/cto/FullFrontendGenerator";
import PlugAndPlayModules from "../components/cto/PlugAndPlayModules";
import ContextEngineeringModule from "../components/cto/ContextEngineeringModule";

export default function CTOStudio() {
  const [activeTab, setActiveTab] = useState("context");
  const [selectedModules, setSelectedModules] = useState([]);
  const [techStack, setTechStack] = useState({
    frontend: null,
    backend: null,
    database: null,
    hosting: null
  });
  const [contextData, setContextData] = useState({
    prp: "",
    readinessScore: 0,
  });
  const [projectContext, setProjectContext] = useState(null);
  const [isAutoPopulating, setIsAutoPopulating] = useState(true);

  // Enhanced Smart Handshake Protocol states
  const [founderCofounderAgreement, setFounderCofounderAgreement] = useState({
    criticalItems: [],
    optionalItems: [],
    riskyChoices: [],
    founderChoices: [],
    riskAcknowledgments: [],
    isComplete: false,
    agreementTimestamp: null,
    overallReadiness: 0,
    recommendedAction: "Initializing agreement..."
  });

  const [showRiskDialog, setShowRiskDialog] = useState(false);
  const [pendingRiskyChoices, setPendingRiskyChoices] = useState([]);
  const [technicalData, setTechnicalData] = useState(null);

  useEffect(() => {
    // Listen for live updates first
    const handleAIUpdate = (event) => {
      const { action } = event.detail;
      if (action.type === 'update_technical_data') {
        console.log("CTO Studio received live technical data update:", action.data);
        setTechnicalData(prev => ({ ...(prev || {}), ...action.data }));
        autoPopulateFromData(action.data);
      }
    };
    window.addEventListener('aiPageAction', handleAIUpdate);

    // Then load initial data from session storage
    const workspaceDataJSON = sessionStorage.getItem('foundersWorkspaceData');
    if (workspaceDataJSON) {
      try {
        const data = JSON.parse(workspaceDataJSON);
        setTechnicalData(data);
        autoPopulateFromData(data);
      } catch (error) {
        console.error("Error auto-populating CTO Studio:", error);
        setIsAutoPopulating(false);
      }
    } else {
      setIsAutoPopulating(false);
    }

    return () => window.removeEventListener('aiPageAction', handleAIUpdate);
  }, []);

  const autoPopulateFromData = (data) => {
    if (!data || !data.clarificationData) {
      setIsAutoPopulating(false);
      return;
    }

    console.log("Auto-populating CTO Studio with clarification data:", data.clarificationData);

    const clarificationData = data.clarificationData;
    setProjectContext(clarificationData);

    const autoGeneratedPRP = generateCompletePRP(clarificationData);
    const autoSuggestedModules = generateModuleSuggestions(clarificationData);
    const autoTechStack = generateTechStackSuggestions(clarificationData);

    setContextData({
      prp: autoGeneratedPRP,
      readinessScore: calculateReadinessScore(clarificationData),
      projectVision: data.dreamStatement,
      featureModules: clarificationData.features?.map(f => f.name) || [],
      apiLibrary: generateAPIDocumentation(clarificationData),
      promptExamples: generatePromptExamples(clarificationData),
      useCaseScenarios: generateUseCaseScenarios(clarificationData),
      contextMemory: generateContextMemory(data),
      successMetrics: generateSuccessMetrics(clarificationData),
      referenceUI: generateUIReference(clarificationData)
    });

    setSelectedModules(autoSuggestedModules);
    setTechStack(autoTechStack);

    generateFounderCofounderAgreement(clarificationData);
  };

  // Enhanced Smart Handshake Protocol Generator
  const generateFounderCofounderAgreement = async (data) => {
    try {
      const response = await InvokeLLM({
        prompt: `
          Generate a comprehensive Founder-Cofounder Agreement protocol for this project based on the following project details:
          
          Business Concept: ${data.businessConcept || 'Not provided'}
          Features: ${JSON.stringify(data.features || [])}
          User Flows: ${JSON.stringify(data.userFlows || [])}
          Requirements: ${JSON.stringify(data.requirements || [])}
          
          Create a smart handshake protocol that ensures maximum clarity and minimizes assumptions. Divide the agreement into three categories:
          
          CRITICAL ITEMS (Must be explicitly agreed upon and completed before code generation for production):
          For each critical item, describe what needs to be defined/finalized and what evidence is required to mark it as complete.
          
          OPTIONAL ITEMS (Can be evolved later with explicit founder choice):
          For each optional item, describe it and indicate if it's something that can reasonably be deferred until after the initial launch (MVP).
          
          RISKY CHOICES (Specific identified risks or incomplete aspects that require explicit founder acknowledgment to proceed with code generation):
          For each risky choice, identify the incomplete aspect, describe the potential risk if proceeding without addressing it, assign a risk level (low, medium, high, critical), provide specific consent language the founder must agree to, and suggest a mitigation strategy if they choose to proceed.
          
          Ensure all items have a unique 'id', a 'category', and clear descriptions.
          The response should also include an 'overallReadiness' score (0-100) reflecting how complete the project definition is according to this agreement, and a 'recommendedAction' based on the current state.
        `,
        response_json_schema: {
          type: "object",
          properties: {
            criticalItems: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  category: { type: "string" },
                  item: { type: "string" },
                  description: { type: "string" },
                  evidenceRequired: { type: "string" },
                  isComplete: { type: "boolean" },
                  completionEvidence: { type: "string" }
                },
                required: ["id", "category", "item", "description", "evidenceRequired"]
              }
            },
            optionalItems: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  category: { type: "string" },
                  item: { type: "string" },
                  description: { type: "string" },
                  canEvolvePostLaunch: { type: "boolean" },
                  founderChoiceRequired: { type: "boolean" },
                  isIncluded: { type: "boolean" }
                },
                required: ["id", "category", "item", "description", "canEvolvePostLaunch", "founderChoiceRequired"]
              }
            },
            riskyChoices: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  category: { type: "string" },
                  choice: { type: "string" },
                  riskDescription: { type: "string" },
                  riskLevel: { type: "string", enum: ["low", "medium", "high", "critical"] },
                  consentLanguage: { type: "string" },
                  mitigationStrategy: { type: "string" },
                  founderConsent: { type: "boolean" }
                },
                required: ["id", "category", "choice", "riskDescription", "riskLevel", "consentLanguage", "mitigationStrategy"]
              }
            },
            overallReadiness: { type: "number", minimum: 0, maximum: 100 },
            recommendedAction: { type: "string" }
          },
          required: ["criticalItems", "optionalItems", "riskyChoices", "overallReadiness", "recommendedAction"]
        }
      });

      // Initialize items with default user interaction states
      const initialCriticalItems = (response.criticalItems || []).map(item => ({
        ...item,
        isComplete: item.isComplete !== undefined ? item.isComplete : false
      }));
      const initialOptionalItems = (response.optionalItems || []).map(item => ({
        ...item,
        isIncluded: item.isIncluded !== undefined ? item.isIncluded : false
      }));
      const initialRiskyChoices = (response.riskyChoices || []).map(item => ({
        ...item,
        founderConsent: item.founderConsent !== undefined ? item.founderConsent : false
      }));

      setFounderCofounderAgreement(prev => ({
        ...prev,
        criticalItems: initialCriticalItems,
        optionalItems: initialOptionalItems,
        riskyChoices: initialRiskyChoices,
        overallReadiness: response.overallReadiness || 0,
        recommendedAction: response.recommendedAction || "Complete critical items and acknowledge risks to proceed."
      }));

      // Identify risky choices that need consent
      const risksToAcknowledge = initialRiskyChoices.filter(choice => !choice.founderConsent);
      setPendingRiskyChoices(risksToAcknowledge);
      setIsAutoPopulating(false);
    } catch (error) {
      console.error("Error generating Founder-Cofounder Agreement:", error);
      setFounderCofounderAgreement({
        criticalItems: [],
        optionalItems: [],
        riskyChoices: [],
        founderChoices: [],  
        riskAcknowledgments: [],
        isComplete: false,
        agreementTimestamp: null,
        overallReadiness: 0,
        recommendedAction: "Failed to generate agreement. Please try again."
      });
      setIsAutoPopulating(false);
    }
  };

  const handleCriticalItemToggle = (itemId) => {
    setFounderCofounderAgreement(prev => {
      const updatedCriticalItems = prev.criticalItems.map(item =>
        item.id === itemId
          ? { ...item, isComplete: !item.isComplete }
          : item
      );

      const allCriticalComplete = updatedCriticalItems.every(item => item.isComplete);
      const allRisksAcknowledged = pendingRiskyChoices.length === 0;

      return {
        ...prev,
        criticalItems: updatedCriticalItems,
        isComplete: allCriticalComplete && allRisksAcknowledged
      };
    });
  };

  const handleOptionalItemToggle = (itemId) => {
    setFounderCofounderAgreement(prev => ({
      ...prev,
      optionalItems: prev.optionalItems.map(item =>
        item.id === itemId
          ? { ...item, isIncluded: !item.isIncluded }
          : item
      ),
      founderChoices: prev.optionalItems.filter(item => item.isIncluded).map(item => item.id)
    }));
  };

  const handleRiskConsent = (risks) => {
    setFounderCofounderAgreement(prev => {
      const updatedRiskyChoices = prev.riskyChoices.map(risk =>
        risks.some(r => r.id === risk.id)
          ? { ...risk, founderConsent: true }
          : risk
      );

      const newRiskAcknowledgments = [...prev.riskAcknowledgments, ...risks.map(r => r.id)];

      const allCriticalComplete = prev.criticalItems.every(item => item.isComplete);
      const allRisksAcknowledged = updatedRiskyChoices.every(risk => risk.founderConsent);

      return {
        ...prev,
        riskyChoices: updatedRiskyChoices,
        riskAcknowledgments: newRiskAcknowledgments,
        isComplete: allCriticalComplete && allRisksAcknowledged,
        agreementTimestamp: new Date().toISOString()
      };
    });
    setPendingRiskyChoices([]);
    setShowRiskDialog(false);
  };

  const handleProceedWithRisks = () => {
    if (pendingRiskyChoices.length > 0) {
      setShowRiskDialog(true);
    }
  };

  const canProceedToGeneration = () => {
    const allCriticalComplete = founderCofounderAgreement.criticalItems.every(item => item.isComplete);
    const allRisksAcknowledged = pendingRiskyChoices.length === 0;
    return allCriticalComplete && allRisksAcknowledged;
  };

  const generateCompletePRP = (data) => {
    return `# Product Requirement Prompt (PRP)

## Project Vision
${data.businessConcept || 'AI-powered business solution'}

## Core Features & Requirements
${(data.features || []).map(f => `
### ${f.name}
**Description:** ${f.description}
**Priority:** ${f.priority}
**User Story:** ${f.userStory}
**Acceptance Criteria:**
${f.acceptanceCriteria?.map(c => `- ${c}`).join('\n') || '- To be defined'}
**Technical Complexity:** ${f.complexity}
`).join('\n')}

## User Flows
${(data.userFlows || []).map(flow => `
### ${flow.flowName}
**Steps:**
${flow.steps?.map((step, i) => `${i + 1}. ${step}`).join('\n') || 'Steps to be defined'}

**Pain Points to Address:**
${flow.painPoints?.map(p => `- ${p}`).join('\n') || '- To be identified'}
`).join('\n')}

## Technical Requirements
${(data.requirements || []).map(req => `
### ${req.category}
**Requirement:** ${req.requirement}
**Justification:** ${req.justification}
`).join('\n')}

## Success Metrics
- User engagement: Track feature adoption rates
- Performance: Sub-2s load times
- Reliability: 99.9% uptime
- User satisfaction: 4.5+ rating

## Integration Points
- Authentication system
- Payment processing (if applicable)
- Third-party APIs as needed
- Analytics and monitoring

## Deployment Requirements
- Scalable architecture
- Security best practices
- Mobile-responsive design
- SEO optimization
`;
  };

  const generateModuleSuggestions = (data) => {
    const modules = [];
    const featuresText = JSON.stringify(data.features || []).toLowerCase();
    const conceptText = (data.businessConcept || '').toLowerCase();

    if (featuresText.includes('payment') || conceptText.includes('payment')) {
      modules.push({
        id: 'stripe-payments',
        name: 'Stripe Payment Gateway',
        description: 'Accept credit cards and handle payments',
        icon: 'CreditCard'
      });
    }

    if (featuresText.includes('user') || featuresText.includes('auth')) {
      modules.push({
        id: 'auth-system',
        name: 'User Authentication',
        description: 'Secure user login and registration',
        icon: 'Lock'
      });
    }

    if (featuresText.includes('email') || featuresText.includes('notification')) {
      modules.push({
        id: 'email-system',
        name: 'Email Notifications',
        description: 'Automated email system',
        icon: 'Mail'
      });
    }

    if (featuresText.includes('analytics') || featuresText.includes('dashboard')) {
      modules.push({
        id: 'analytics',
        name: 'Analytics Dashboard',
        description: 'Track user behavior and metrics',
        icon: 'BarChart3'
      });
    }

    return modules;
  };

  const generateTechStackSuggestions = (data) => {
    const requirements = data.requirements || [];
    const features = data.features || [];

    const hasRealTimeFeatures = requirements.some(r =>
      r.requirement.toLowerCase().includes('real-time') ||
      r.requirement.toLowerCase().includes('live')
    );

    const hasComplexBackend = features.some(f =>
      f.complexity === 'complex' ||
      f.description.toLowerCase().includes('algorithm')
    );

    return {
      frontend: hasRealTimeFeatures ? 'React' : 'React',
      backend: hasComplexBackend ? 'Python (Django)' : 'Node.js (Express)',
      database: hasComplexBackend ? 'PostgreSQL' : 'MongoDB',
      hosting: 'Vercel'
    };
  };

  const generateAPIDocumentation = (data) => {
    return `# API Documentation

## Authentication
\`\`\`bash
curl -X POST https://api.yourapp.com/auth/login \\
  -H "Content-Type: application/json" \\
  -d '{"email": "user@example.com", "password": "password"}'
\`\`\`

## Core Endpoints
${(data.features || []).map(f => `
### ${f.name} API
\`\`\`bash
curl -X GET https://api.yourapp.com/${f.name.toLowerCase().replace(/\s+/g, '-')} \\
  -H "Authorization: Bearer YOUR_TOKEN"
\`\`\`
`).join('\n')}
`;
  };

  const generatePromptExamples = (data) => {
    return (data.features || []).slice(0, 3).map(f => ({
      input: `How do I use the ${f.name} feature?`,
      output: `${f.description}. ${f.userStory}`
    }));
  };

  const generateUseCaseScenarios = (data) => {
    return {
      normal: `User successfully uses the main features: ${(data.features || []).map(f => f.name).join(', ')}`,
      edge: `User encounters slow internet or partial feature failures`,
      fail: `System handles gracefully when core services are unavailable`
    };
  };

  const generateContextMemory = (workspaceData) => {
    const clarificationData = workspaceData.clarificationData;
    if (!clarificationData) return "";

    return `You are an AI assistant for ${clarificationData.businessConcept || 'this project'}.

Your role is to help users with:
${(clarificationData.features || []).map(f => `- ${f.name}: ${f.description}`).join('\n')}

Always be helpful, accurate, and focused on the user's goals.`;
  };

  const generateSuccessMetrics = (data) => {
    return (data.features || []).slice(0, 3).map(f => ({
      test: `Does the ${f.name} feature work as expected?`,
      expected: `Yes, ${f.userStory.toLowerCase()}`
    }));
  };

  const generateUIReference = (data) => {
    return `UI should support: ${(data.features || []).map(f => f.name).join(', ')}`;
  };

  const calculateReadinessScore = (data) => {
    let score = 0;
    if (data.businessConcept) score += 2;
    if (data.features && data.features.length > 0) score += 3;
    if (data.userFlows && data.userFlows.length > 0) score += 2;
    if (data.requirements && data.requirements.length > 0) score += 3;
    return Math.min(score, 10);
  };

  if (isAutoPopulating) {
    return (
      <div className="min-h-screen bg-transparent flex items-center justify-center">
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          className="text-center"
        >
          <motion.div
            animate={{ rotate: 360 }}
            transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
            className="w-16 h-16 mx-auto mb-4 bg-gradient-to-r from-orange-500 to-pink-500 rounded-full flex items-center justify-center"
          >
            <BrainCircuit className="w-8 h-8 text-white" />
          </motion.div>
          <h2 className="text-2xl font-bold text-gray-900 mb-2">CTO Agent Initializing</h2>
          <p className="text-gray-600">Autonomous technical co-founder analyzing your complete project context...</p>
        </motion.div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-transparent">
      <div className="max-w-7xl mx-auto p-6">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6 }}
          className="space-y-6"
        >
          {/* Header */}
          <div className="text-center mb-8">
            <motion.div
              className="flex items-center justify-center gap-4 mb-6"
              initial={{ opacity: 0, y: -20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.2 }}
            >
              <div className="w-20 h-20 bg-gradient-to-r from-orange-500 via-red-500 to-pink-500 rounded-3xl flex items-center justify-center shadow-xl">
                <Wrench className="w-10 h-10 text-white" />
              </div>
              <div className="text-left">
                <h1 className="text-5xl font-bold text-gray-900 mb-2">üîß CTO Studio</h1>
                <p className="text-xl text-gray-600">Autonomous Technical Co-Founder & Smart Handshake Protocol</p>
              </div>
            </motion.div>
          </div>

          {/* Smart Handshake Protocol */}
          <Card className="border-2 border-orange-200 bg-gradient-to-r from-orange-50 to-red-50">
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Users className="w-5 h-5 text-orange-600" />
                Founder-Cofounder Agreement Protocol
                {founderCofounderAgreement.isComplete && (
                  <Badge className="bg-green-100 text-green-800 ml-2">
                    ‚úÖ Agreement Complete
                  </Badge>
                )}
                {!founderCofounderAgreement.isComplete && (
                  <Badge className="bg-red-100 text-red-800 ml-2">
                    ‚ö†Ô∏è Agreement Pending
                  </Badge>
                )}
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="mb-4">
                <p className="text-gray-700 mb-2">
                  As your AI Technical Co-Founder, I require our formal agreement before generating production code.
                  This ensures we're 100% aligned and eliminates assumptions.
                </p>
                <div className="bg-blue-50 p-3 rounded-lg">
                  <p className="text-sm text-blue-800">
                    <strong>Smart Protocol:</strong> Critical items must be completed. Optional items can evolve post-launch with your consent.
                    Risky choices require explicit acknowledgment - you can proceed at your own risk with informed consent.
                  </p>
                </div>
              </div>

              <Tabs defaultValue="critical" className="w-full">
                <TabsList className="grid w-full grid-cols-3">
                  <TabsTrigger value="critical" className="gap-2">
                    <Shield className="w-4 h-4" />
                    Critical Items ({founderCofounderAgreement.criticalItems.filter(item => item.isComplete).length}/{founderCofounderAgreement.criticalItems.length})
                  </TabsTrigger>
                  <TabsTrigger value="optional" className="gap-2">
                    <Settings className="w-4 h-4" />
                    Optional Items ({founderCofounderAgreement.optionalItems.filter(item => item.isIncluded).length}/{founderCofounderAgreement.optionalItems.length})
                  </TabsTrigger>
                  <TabsTrigger value="risks" className="gap-2">
                    <AlertTriangle className="w-4 h-4" />
                    Risks ({pendingRiskyChoices.length})
                  </TabsTrigger>
                </TabsList>

                <TabsContent value="critical" className="mt-4">
                  <div className="space-y-3">
                    {founderCofounderAgreement.criticalItems.length === 0 ? (
                      <p className="text-gray-500">No critical items identified yet.</p>
                    ) : (
                      founderCofounderAgreement.criticalItems.map(item => (
                        <div key={item.id} className="flex items-start gap-3 p-4 bg-white rounded-lg shadow-sm border">
                          <Checkbox
                            checked={item.isComplete}
                            onCheckedChange={() => handleCriticalItemToggle(item.id)}
                            className="mt-1 w-5 h-5"
                          />
                          <div className="flex-1">
                            <div className="font-medium text-gray-900">{item.item}</div>
                            <div className="text-sm text-gray-600 mt-1">{item.description}</div>
                            <Badge variant="outline" className="mt-2 bg-red-50 text-red-700 border-red-200">
                              {item.category}
                            </Badge>
                            <div className="text-xs text-gray-500 mt-2">
                              <strong>Evidence Required:</strong> {item.evidenceRequired}
                            </div>
                          </div>
                        </div>
                      ))
                    )}
                  </div>
                </TabsContent>

                <TabsContent value="optional" className="mt-4">
                  <div className="space-y-3">
                    {founderCofounderAgreement.optionalItems.length === 0 ? (
                      <p className="text-gray-500">No optional items identified yet.</p>
                    ) : (
                      founderCofounderAgreement.optionalItems.map(item => (
                        <div key={item.id} className="flex items-start gap-3 p-4 bg-white rounded-lg shadow-sm border">
                          <Checkbox
                            checked={item.isIncluded}
                            onCheckedChange={() => handleOptionalItemToggle(item.id)}
                            className="mt-1 w-5 h-5"
                          />
                          <div className="flex-1">
                            <div className="font-medium text-gray-900">{item.item}</div>
                            <div className="text-sm text-gray-600 mt-1">{item.description}</div>
                            <Badge variant="outline" className="mt-2 bg-blue-50 text-blue-700 border-blue-200">
                              {item.category}
                            </Badge>
                            {item.canEvolvePostLaunch && (
                              <div className="text-xs text-green-600 mt-2">
                                ‚úì Can be refined after launch
                              </div>
                            )}
                          </div>
                        </div>
                      ))
                    )}
                  </div>
                </TabsContent>

                <TabsContent value="risks" className="mt-4">
                  <div className="space-y-3">
                    {pendingRiskyChoices.length === 0 && founderCofounderAgreement.riskyChoices?.length > 0 && (
                      <p className="text-green-600 flex items-center gap-2">
                        <CheckCircle className="w-5 h-5" /> All identified risks have been acknowledged.
                      </p>
                    )}
                    {pendingRiskyChoices.length === 0 && founderCofounderAgreement.riskyChoices?.length === 0 && (
                      <p className="text-gray-500">No specific risks identified for this project at this stage.</p>
                    )}
                    {pendingRiskyChoices.map(risk => (
                      <div key={risk.id} className="p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                        <div className="flex items-start gap-3">
                          <AlertTriangle className="w-5 h-5 text-yellow-600 mt-1" />
                          <div className="flex-1">
                            <div className="font-medium text-gray-900">{risk.choice}</div>
                            <div className="text-sm text-gray-600 mt-1">{risk.riskDescription}</div>
                            <div className="flex items-center gap-2 mt-2">
                              <Badge className={`${
                                risk.riskLevel === 'critical' ? 'bg-red-100 text-red-800' :
                                  risk.riskLevel === 'high' ? 'bg-orange-100 text-orange-800' :
                                    risk.riskLevel === 'medium' ? 'bg-yellow-100 text-yellow-800' :
                                      'bg-blue-100 text-blue-800'
                                }`}>
                                {risk.riskLevel} risk
                              </Badge>
                              <Badge variant="outline" className="bg-gray-50 text-gray-700">
                                {risk.category}
                              </Badge>
                            </div>
                            <div className="text-sm text-blue-800 mt-2 bg-blue-50 p-2 rounded">
                              <strong>Mitigation:</strong> {risk.mitigationStrategy}
                            </div>
                          </div>
                        </div>
                      </div>
                    ))}
                    {pendingRiskyChoices.length > 0 && (
                      <Button
                        onClick={handleProceedWithRisks}
                        className="w-full bg-yellow-600 hover:bg-yellow-700"
                      >
                        I Accept These Risks & Want to Proceed
                      </Button>
                    )}
                  </div>
                </TabsContent>
              </Tabs>

              <div className="mt-6 p-4 bg-gray-50 rounded-lg">
                <div className="flex justify-between items-center">
                  <div>
                    <div className="font-medium text-gray-900">Agreement Status</div>
                    <div className="text-sm text-gray-600">
                      {founderCofounderAgreement.recommendedAction}
                    </div>
                  </div>
                  <div className="text-right">
                    <div className="text-2xl font-bold text-orange-600">
                      {founderCofounderAgreement.overallReadiness || 0}%
                    </div>
                    <div className="text-xs text-gray-500">Readiness</div>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Main Content - Show with informed consent model */}
          {(canProceedToGeneration() || founderCofounderAgreement.agreementTimestamp) && (
            <Card className="border-0 shadow-lg bg-white/90 backdrop-blur-sm">
              <CardHeader className="border-b border-gray-100">
                <div className="flex items-center justify-between">
                  <CardTitle className="flex items-center gap-2">
                    <Settings className="w-5 h-5 text-orange-600" />
                    Technical Architecture & Complete Code Generation
                  </CardTitle>
                  <Badge className={`${canProceedToGeneration() ? 'bg-green-100 text-green-800' : 'bg-yellow-100 text-yellow-800'}`}>
                    {canProceedToGeneration() ? '‚úÖ Ready for Production Code' : '‚ö†Ô∏è Proceeding with Acknowledged Risks'}
                  </Badge>
                </div>
              </CardHeader>

              <CardContent className="p-0">
                <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
                  <TabsList className="grid w-full grid-cols-4 bg-gray-50 rounded-none border-b">
                    <TabsTrigger value="context" className="gap-2 data-[state=active]:bg-purple-100 data-[state=active]:text-purple-700">
                      <BrainCircuit className="w-4 h-4" />
                      Context Engineer
                    </TabsTrigger>
                    <TabsTrigger value="stack" className="gap-2">
                      <Code className="w-4 h-4" />
                      Tech Stack
                    </TabsTrigger>
                    <TabsTrigger value="frontend" className="gap-2 data-[state=active]:bg-emerald-100 data-[state=active]:text-emerald-700">
                      <Rocket className="w-4 h-4" />
                      Complete Frontend
                    </TabsTrigger>
                    <TabsTrigger value="modules" className="gap-2">
                      <Puzzle className="w-4 h-4" />
                      Modules
                      {selectedModules.length > 0 && (
                        <Badge variant="secondary" className="ml-1 h-5">
                          {selectedModules.length}
                        </Badge>
                      )}
                    </TabsTrigger>
                  </TabsList>

                  <TabsContent value="context" className="m-0">
                    <ContextEngineeringModule
                      contextData={contextData}
                      setContextData={setContextData}
                    />
                  </TabsContent>

                  <TabsContent value="stack" className="m-0">
                    <TechStackRecommendations
                      techStack={techStack}
                      onUpdateTechStack={setTechStack}
                    />
                  </TabsContent>

                  <TabsContent value="frontend" className="m-0">
                    <FullFrontendGenerator
                      projectContext={projectContext}
                      selectedModules={selectedModules}
                      techStack={techStack}
                      contextData={contextData}
                      validationComplete={true}
                      founderCofounderAgreement={founderCofounderAgreement}
                    />
                  </TabsContent>

                  <TabsContent value="modules" className="m-0">
                    <PlugAndPlayModules
                      selectedModules={selectedModules}
                      onUpdateModules={setSelectedModules}
                      techStack={techStack}
                    />
                  </TabsContent>
                </Tabs>
              </CardContent>
            </Card>
          )}

          {/* Risk Consent Dialog */}
          <AnimatePresence>
            {showRiskDialog && (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                className="fixed inset-0 bg-black/50 flex items-center justify-center z-50"
              >
                <motion.div
                  initial={{ scale: 0.9, opacity: 0 }}
                  animate={{ scale: 1, opacity: 1 }}
                  exit={{ scale: 0.9, opacity: 0 }}
                  className="bg-white rounded-xl p-6 max-w-2xl mx-4 max-h-[80vh] overflow-y-auto shadow-lg"
                >
                  <div className="flex items-center gap-3 mb-4">
                    <AlertTriangle className="w-8 h-8 text-yellow-600" />
                    <div>
                      <h3 className="text-xl font-bold text-gray-900">Founder Consent Required</h3>
                      <p className="text-gray-600">You're choosing to proceed with some identified risks. Please review and acknowledge:</p>
                    </div>
                  </div>

                  <div className="space-y-4 mb-6">
                    {pendingRiskyChoices.map(risk => (
                      <div key={risk.id} className="p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                        <div className="font-medium text-gray-900 mb-2">{risk.choice}</div>
                        <div className="text-sm text-gray-700 mb-3">{risk.consentLanguage}</div>
                        <div className="text-xs text-blue-800 bg-blue-50 p-2 rounded">
                          <strong>Our mitigation plan:</strong> {risk.mitigationStrategy}
                        </div>
                      </div>
                    ))}
                  </div>

                  <div className="flex gap-3 justify-end">
                    <Button variant="outline" onClick={() => setShowRiskDialog(false)}>
                      Cancel
                    </Button>
                    <Button
                      onClick={() => handleRiskConsent(pendingRiskyChoices)}
                      className="bg-yellow-600 hover:bg-yellow-700"
                    >
                      I Acknowledge These Risks & Consent to Proceed
                    </Button>
                  </div>
                </motion.div>
              </motion.div>
            )}
          </AnimatePresence>
        </motion.div>
      </div>
    </div>
  );
}